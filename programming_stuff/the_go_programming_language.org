#+TITLE: The Go Programming Language
#+OPTIONS: num:nil; ^:nil; ':t

* Prerequisites:
+ Install Go: ~sudo dnf install golang~

* Chapter 1: Tutorial

** Hello World
+ Go "Hello World"
  #+begin_src go
    package main

    import "fmt"

    func main() {
        fmt.Println("Hello, world")
    }
  #+end_src
+ To build and run Go programs:
  + ~go run <file>~ builds and runs an individual file
  + ~go build <file>~ builds a file and outputs an executable
+ Go code organization
  + Go code is organized into packages, which are roughly analogous to libraries or modules
  + Package ~main~ defines an executable program
  + Function ~main~ is where execution starts
  + Must import only the packages that you need -- unused imports are a compiler error
+ Formatting
  + Go is prescriptive in its formatting
  + Run ~go fmt~ on your code when you save it
  + Note: Go uses tabs for indentation

** Command-line arguments
+ To process command-line arguments, import the "os" module
+ Command-line arguments are stored in ~os.Args~
+ Example:
  #+begin_src go
    package main

    import (
        "fmt"
        "os"
    )

    func main() {
        var s, sep string
        for i := 1; i < len(os.Args); i++ {
            s += sep + os.Args[i]
            sep = " "
        }
        fmt.Println(s)
    }
  #+end_src
+ In this example we introduce variable declarations, assignment, and for loops
  + Variable declarations
    + To declare a variable in Go: ~var <variable name> <variable type>~
    + We can also use "short declarations": ~name := value~
    + Short declarations set the type of the variable automatically, depending on the type of the value being assigned
    + Four ways of declaring variables in Go:
      #+begin_src go
        s := ""
        var s string
        var s = ""
        var s string = ""
      #+end_src
      + First form, short declaration, is the most compact, but it may only be used inside a function, and may not be used to initialize package-level variables
      + Second form relies on default initialization to the zero value for strings, which is ~""~
      + Third form -- rarely used except when declaring multiple variables
      + Fourth form -- completely explicit about the variable's type
        + Used only when the variable's type is different from the type of the initial value (e.g. when assigning ~0~ to a floating point value)
      + In general, prefer the first two forms
  + Looping
    + The only looping construct in Go is ~for~
    + ~for~ comes in a number of forms:
      + ~for <condition>~ is roughly analogous to ~while~
      + ~for~ by itself is an infinite loop
      + The ~for~ we've seen, ~for initialization; condition; post~ is a traditional "for loop"
    + Another version of the ~for~ loop iterates over a /range/ of arguments
      #+begin_src go
        func main() {
            s, sep := "", ""
            for _, arg := range os.Args[1:] {
                s = sep + arg
                sep = " "
            }
        }
      #+end_src
    + In each iteration of the loop, ~range~ produces a pair of values: the index of the element and the element itself
    + We're not interested in the index, so we use the /blank identifier/ ~_~ to throw away the index
      + Can use the blank identifier any time an assignment is expected, but you don't care about one of the values

** Finding duplicate lines
+ Example introduces the ~if~ statement, the ~map~ datatype and the ~bufio~ package
+ Problem: print each line that appears more than once in the standard input
  #+begin_src go
    import (
        "bufio"
        "fmt"
        "os"
    )

    func main() {
        counts := make(map[string]int)
        input := bufio.NewScanner(os.Stdin)
        for input.Scan() {
            counts[input.Text()]++
        }
        for line, n := range counts {
            if n > 1 {
                fmt.Printf("%d\t%s\n", n, line)
            }
        }
    }
  #+end_src
  + As with for parentheses are never used around the condition of an ~if~ statement and braces are required for the body
  + Using ~range~ on a map results in a sequence of key/value pairs
  + map
    + Set of key/value pairs
    + Constant time operations for store, retrieve, test for item in map
    + Key may be of any type that can be compared with ==
    + Value may be anything at all
    + Accessing the map for a key that does not exist returns the zero-value for its type (for ~int~ that value is 0, which is why we're able to immediately increment it)
    + Create new maps with ~make~ built-in, which has other uses as well
  + ~bufio~
    + ~bufio~ has a useful type, ~Scanner~ which reads input and automatically chunks it by line
      + ~Scan()~ reads the next line from the input stream and removes the newline
      + ~Text()~ retrieves the next line
  + ~fmt~
    + Formatted output
    + ~Printf()~ is basically the same as ~printf~ from C
    + ~Printf()~ types:
      + ~%d~: decimal integer
      + ~%x, %o, %b~: integer in hexadecimal, octal, or binary
      + ~%f, %g, %e~: floating point number, extra-precision floating point, floating point in exponential format
      + ~%t~: boolean (true or false)
      + ~%c~: /rune/ (Unicode code point)
      + ~%s~: string
      + ~%q~: quoted string ~"abc"~ or run ~'c'~
      + ~%v~: Any value in "natural" format
      + ~%T~: the type of any value
      + ~%%~: a literal percent symbol
+ Update the duplicate lines program to handle either standard input or a list of files:
  #+begin_src go
    import (
        "bufio"
        "fmt"
        "os"
    )

    func main() {
        counts := make(map[string]int)
        files := os.Args[1:]
        if len(files) == 0 {
            countLines(os.Stdin, counts)
        } else {
            for _, filename := range files {
                f, err = os.Open(filename)
                if err != nil {
                    fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
                    continue
                }
                countLines(f, counts)
                f.Close()
            }
        }
        for line, n := range counts {
            if n > 1 {
                fmt.Printf("%d\t%s\n", n, line)
            }
        }
    }

    func countLines(f *os.File, counts map[string]int) {
        input := bufio.NewScanner(f)
        for input.Scan() {
            counts[input.Text()]++
        }
    }
  #+end_src
  + ~os.Open()~ returns two values:
    + File ~*os.File~
    + ~err~ -- the standard error value
    + If ~err~ is nil, the operation completed without errors
    + If ~err~ is not nil, it should be handled somehow
  + Everything created by ~make~ is a reference
  + We can pass the ~map~ we get from ~make~ to ~countLines~ and any updates to the map will also be visible from ~main~
+ Instead of reading lines in a streaming fashion, we can read entire files into memory at once:
  #+begin_src go
    import (
        "fmt"
        "io/ioutil"
        "os"
        "string"
    )

    func main() {
        counts := make(map[string]int)
        for _, filename = range(os.Args[1:]) {
            data, err := ioutils.ReadFile(filename)
            if err != nil {
                fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
                continue
            }
            for _, line := string.Split(string(data)) {
                counts[line]++
            }
        }

        for n, line := range counts {
            fmt.Printf("%d\t%s\n", n, line)
        }
    }
  #+end_src
